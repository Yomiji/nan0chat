package nan0chat

import (
	"github.com/yomiji/nan0"
	"time"
	"net"
	"io"
	"fmt"
)

type ChatServer struct {
	users    map[int64]*ConnectedUser
	internal *nan0.Service
}

type ConnectedUser struct {
	conn net.Conn
}

func Serve(port int) (err error) {
	// create the server descriptor
	service := &ChatServer{
		internal: &nan0.Service{
			ServiceName: "Nan0 Chat",
			Port:        int32(port),
			HostName:    "localhost",
			StartTime:   time.Now().Unix(),
			ServiceType: "Chat",
		},
		users: make(map[int64]*ConnectedUser),
	}

	// start listening for clients
	listener, err := service.internal.Start()
	if err != nil {
		return err
	}
	// shutdown server on exit or error
	defer listener.Close()

	fmt.Println("Secure nan0chat server started. Use interrupt command (ctrl+c) to exit.")

	// start handling client requests indefinitely
	for ; ; {
		conn, err := listener.Accept()
		if err != nil {
			return err
		}

		// when we get a new connection, create a random user id and save the connection to the map of connected clients
		newUserId := random.Int63()
		service.users[newUserId] = &ConnectedUser{
			conn: conn,
		}

		// start a service handler for all messages generated by that client
		fmt.Printf("New user %v connected.\n", newUserId)
		go service.startDistributor(newUserId, conn)
	}
	return
}

// Starts a handler for the given user that will distribute the user's messages to each other connected user
func (s *ChatServer) startDistributor(userId int64, conn net.Conn) {
	defer conn.Close()
	for ; ; {
		// make a default message buffer
		buff := make([]byte, 1024)
		// eventually compose the message inside this var
		message := make([]byte, 0)
		// set a read deadline, when we've stopped getting data, the message may be complete
		conn.SetReadDeadline(time.Now().Add(500 * time.Millisecond))
		// start composing the entire message from the client, taking from the buffer until EOF or timeout
		for n, err := conn.Read(buff); !(n == 0 || err == io.EOF); n, err = conn.Read(buff) {
			message = append(message, buff[:n]...)
		}
		// if we have some data inside the message
		if len(message) > 0 {
			// broadcast the message to all connected clients that are NOT the client that generated the message
			// we assume that the subject client has kept track of its own message
			for id, user := range s.users {
				if id != userId {
					err := user.conn.SetWriteDeadline(time.Now().Add(15 * time.Second))
					handleErr(err, nil)
					_, err = user.conn.Write(message)
					handleErr(err, nil)
				}
			}
		}
		// a little rest to free up some cpu cycles
		time.Sleep(30 * time.Millisecond)
	}
}
